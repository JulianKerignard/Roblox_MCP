-- Script serveur principal pour le jeu Collecteur de Gemmes
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Charger le module GemSystem
local GemSystem = require(ReplicatedStorage.Shared.GemSystem)

-- Variables
local gemsFolder = nil
local remotes = nil
local activeGems = {}

-- Initialisation
local function Initialize()
    -- Cr√©er le dossier pour les gemmes
    gemsFolder = workspace:FindFirstChild("GemsFolder")
    if not gemsFolder then
        gemsFolder = Instance.new("Folder")
        gemsFolder.Name = "GemsFolder"
        gemsFolder.Parent = workspace
    end
    
    
    -- Configurer les RemoteEvents
    local success, result = pcall(function()
        return GemSystem.SetupRemotes()
    end)
    
    if success then
        remotes = result
        print("üéÆ Collecteur de Gemmes initialis√©!")
    else
        warn("‚ö†Ô∏è Erreur lors de l'initialisation des RemoteEvents:", result)
    end
end

-- Cr√©er les leaderstats pour un joueur
local function SetupLeaderstats(player)
    local leaderstats = Instance.new("Folder")
    leaderstats.Name = "leaderstats"
    leaderstats.Parent = player
    
    local gems = Instance.new("IntValue")
    gems.Name = "Gems"
    gems.Value = 0
    gems.Parent = leaderstats
    
    -- Envoyer le score initial au client
    task.wait(1) -- Attendre que le client soit pr√™t
    if remotes and remotes.UpdateScore then
        remotes.UpdateScore:FireClient(player, gems.Value)
    end
end

-- G√©rer la collection d'une gemme
local function CollectGem(gem, character)
    print("üîç CollectGem appel√©e pour", gem.Name)
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then 
        print("‚ùå Pas d'humanoid ou humanoid mort")
        return 
    end
    
    local player = Players:GetPlayerFromCharacter(character)
    if not player then 
        print("‚ùå Pas de joueur trouv√©")
        return 
    end
    
    -- R√©cup√©rer les donn√©es de la gemme
    local gemData = gem:FindFirstChild("GemData")
    if not gemData then 
        print("‚ùå Pas de GemData")
        return 
    end
    
    local points = gemData:FindFirstChild("Points")
    local gemType = gemData:FindFirstChild("Type")
    if not points or not gemType then 
        print("‚ùå Points ou Type manquant")
        return 
    end
    
    print("‚úÖ Gemme valide:", gemType.Value, "Points:", points.Value)
    
    -- Mettre √† jour le score
    local leaderstats = player:FindFirstChild("leaderstats")
    if leaderstats then
        local gems = leaderstats:FindFirstChild("Gems")
        if gems then
            gems.Value = gems.Value + points.Value
            print("üíé Score mis √† jour:", gems.Value)
            
            -- Notifier le client
            if remotes and remotes.GemCollected and remotes.UpdateScore then
                print("üì° Envoi des √©v√©nements au client")
                remotes.GemCollected:FireClient(player, gemType.Value, points.Value)
                remotes.UpdateScore:FireClient(player, gems.Value)
        end
    end
    
    -- Supprimer la gemme de la liste active
    for i, activeGem in ipairs(activeGems) do
        if activeGem == gem then
            table.remove(activeGems, i)
            break
        end
    end
    
    -- D√©truire la gemme avec un effet
    -- Recherche manuelle du ParticleEmitter au lieu de FindFirstDescendant
    local function findParticleEmitter(parent)
        for _, child in pairs(parent:GetChildren()) do
            if child:IsA("ParticleEmitter") then
                return child
            elseif child:IsA("Attachment") then
                for _, subchild in pairs(child:GetChildren()) do
                    if subchild:IsA("ParticleEmitter") then
                        return subchild
                    end
                end
            end
        end
        return nil
    end
    
    local particleEmitter = findParticleEmitter(gem)
    if particleEmitter then
        particleEmitter.Rate = 100
        particleEmitter:Emit(50)
    end
    
    gem.Transparency = 1
    gem.CanCollide = false
    Debris:AddItem(gem, 0.5)
end

-- Faire appara√Ætre une gemme
local function SpawnGem()
    -- Choisir un type de gemme al√©atoire
    local gemType = GemSystem.GetRandomGemType()
    print("üé≤ Spawn d'une gemme:", gemType.name)
    
    -- Cr√©er la gemme
    local gem = GemSystem.CreateGem(gemType)
    gem.Position = GemSystem.GetRandomSpawnPosition()
    gem.Parent = gemsFolder
    print("üìç Position de la gemme:", gem.Position)
    
    -- Ajouter √† la liste des gemmes actives
    table.insert(activeGems, gem)
    
    -- Configurer la d√©tection de collision
    gem.Touched:Connect(function(hit)
        local character = hit.Parent
        if character and character:FindFirstChild("Humanoid") then
            -- √âviter les collections multiples
            if gem.Parent then
                gem.Parent = nil
                CollectGem(gem, character)
            end
        end
    end)
    
    -- Supprimer automatiquement apr√®s un certain temps
    Debris:AddItem(gem, GemSystem.Config.GemLifetime)
    
    -- Retirer de la liste active apr√®s expiration
    task.delay(GemSystem.Config.GemLifetime, function()
        for i, activeGem in ipairs(activeGems) do
            if activeGem == gem then
                table.remove(activeGems, i)
                break
            end
        end
    end)
end

-- Animation des gemmes (rotation et flottement)
local function AnimateGems()
    RunService.Heartbeat:Connect(function(deltaTime)
        for _, gem in ipairs(activeGems) do
            if gem and gem.Parent then
                -- Rotation
                gem.CFrame = gem.CFrame * CFrame.Angles(0, deltaTime * GemSystem.Config.RotationSpeed, 0)
                
                -- Flottement sinuso√Ødal
                local time = tick()
                local basePosition = gem.Position
                local floatOffset = math.sin(time * 2 + gem.Position.X) * 0.5
                gem.Position = Vector3.new(basePosition.X, basePosition.Y + floatOffset * deltaTime, basePosition.Z)
            end
        end
    end)
end

-- Boucle de spawn des gemmes
local function StartGemSpawning()
    while true do
        SpawnGem()
        task.wait(GemSystem.Config.SpawnInterval)
    end
end

-- √âv√©nements des joueurs
Players.PlayerAdded:Connect(function(player)
    SetupLeaderstats(player)
    print("üëã " .. player.Name .. " a rejoint le jeu!")
end)

Players.PlayerRemoving:Connect(function(player)
    print("üëã " .. player.Name .. " a quitt√© le jeu!")
end)

-- D√©marrer le jeu
Initialize()
AnimateGems()
task.spawn(StartGemSpawning)

print("üöÄ Serveur du Collecteur de Gemmes d√©marr√©!")